# allOfSoccer UX/UI 연구 및 개선 권장사항

## 요약

현재 iOS 앱 코드베이스를 종합적으로 분석한 결과, 네 가지 주요 기능에서 상당한 UX/UI 개선 기회를 발견했습니다. 이 문서는 구체적인 발견 사항과 실행 가능한 권장사항을 제시합니다.

---

## 1. 팀 매칭 쉽게 하기 - 2단계 팀 모집 프로세스 단순화

### 현재 플로우 분석

**첫 번째 단계 (FirstTeamRecruitmentViewController)**
- 날짜/시간 선택 (RecruitmentCalendarView)
- 위치 입력 (TextField)
- 경기 스타일 옵션 (6v6/11v11, 성별, 신발 종류, 선택사항)
- 참가비 입력

**두 번째 단계 (SecondTeamRecruitmentViewController)**
- 팀 이름 입력
- 나이 범위 슬라이더 (10-70)
- 실력 레벨 슬라이더 (0-6 레벨)
- 팀 소개 (테이블 뷰 또는 직접 입력)
- 연락처 정보
- 정보 동의 체크박스

### 현재 문제점
1. **두 개의 별도 화면** - 화면 간 이동이 번거로움
2. **길어진 폼** - 사용자가 두 번째 화면에서 많이 스크롤해야 함
3. **중복된 헤더** - 두 화면 모두 "팀 모집 글쓰기" 제목 표시
4. **복잡한 실력 레벨 인코딩** - 슬라이더 값과 텍스트 라벨 간의 복잡한 매핑
5. **모달 복잡성** - 팀 소개 입력을 위해 모달 안의 모달 구조

### 권장 UX 개선사항

#### 옵션 A: 단일 화면 폼 with 스마트 스크롤링
**구현 방식:**
- 두 폼을 하나의 스크롤 가능한 폼으로 통합
- "고급 옵션" (나이 범위, 실력)에 축소 가능한 섹션 사용
- 점진적 공개: 처음에는 필수 필드만 표시
- 동적으로 업데이트되는 고정 푸터 버튼 ("계속" → "제출")
- 폼 높이를 40-50% 감소

**UI 변경 사항:**
```
화면 레이아웃:
┌─────────────────────────┐
│ 필수 섹션               │ <- 항상 표시
│ ├─ 날짜/시간           │
│ ├─ 위치                │
│ ├─ 경기 스타일          │
│ └─ 참가비              │
├─────────────────────────┤
│ 팀 섹션                 │ <- 확장 가능
│ ├─ 팀 이름             │
│ └─ 연락처              │
├─────────────────────────┤
│ 선택사항 섹션            │ <- 축소 가능
│ ├─ 나이 범위           │
│ ├─ 실력 레벨           │
│ └─ 소개                │
├─────────────────────────┤
│      [제출]            │ <- 고정 버튼
└─────────────────────────┘
```

#### 옵션 B: 카드 기반 위저드 인터페이스
- 두 단계는 유지하되 시각적 카드로 재설계
- 카드 간 부드러운 전환 효과
- 진행 표시기 (1/2 → 2/2) with 시각적 진행 바
- 단계 간 이동 시 폼 데이터 유지
- "이전" 버튼을 "다음" 버튼과 함께 구현

**장점:**
- 논리적인 정보 그룹화 유지
- 더 명확한 진행 상황 표시
- 사용자가 익숙한 패턴

### 권장 디자인 변경사항
1. "팀 모집 글쓰기"를 맥락에 맞는 제목으로 변경:
   - 1단계: "경기 일정 설정"
   - 2단계: "팀 정보 입력"

2. 실력 레벨 선택 단순화:
   - 슬라이더를 세그먼트 컨트롤 또는 버튼 그룹으로 변경
   - 라벨: 초급, 중급, 상급, 고수 (7개가 아닌 4개 레벨)

3. 나이 범위를 인라인으로 표시:
   - 선택된 범위를 인라인으로 표시 (예: "30-50세")
   - 필요시 탭하여 모달에서 슬라이더 열기

---

## 2. 용병 구하기 쉽게 하기 - 용병 모집 인터페이스 개선

### 현재 구현 분석

**MercenaryMatchViewController 기능:**
- 가로 방향 캘린더 with 날짜 선택
- 필터 버튼 (위치, 포지션, 실력)
- 용병 모집 요청 표시하는 테이블 뷰
- 새 요청 생성 버튼

### 현재 문제점

1. **필터 UI가 불명확함**
   - 필터 버튼이 체크마크 (✓)와 화살표 (▼)를 일관성 없게 표시
   - 사용 가능한 필터와 활성화된 필터 간 시각적 구분 없음
   - ActionSheet picker가 네이티브 같지만 통합되지 않음

2. **캘린더 디자인이 복잡함**
   - 큰 가로 캘린더가 상당한 화면 공간 차지
   - 90일 범위는 과할 수 있음
   - 오늘 날짜를 시각적으로 표시하지 않음

3. **필터 상태가 지속되지 않음**
   - 적용된 필터를 명확하게 표시하지 않음
   - 현재 필터된 내용을 알기 어려움

4. **실력 레벨 옵션이 오래됨**
   - 사용: 초급, 중급, 고급, 고수 (팀 모집과 불일치)

### 권장 UX 개선사항

#### 1. 향상된 필터 UI
**ActionSheet를 현대적인 필터 패널로 교체:**

```swift
// 필터 옵션 재설계
struct FilterOption {
    let type: FilterType
    let options: [FilterItem]
    var selectedItem: FilterItem?
}

enum FilterType {
    case location
    case position
    case skillLevel
}

// 시각적 표시기 구현
- 선택된 항목에만 체크마크 사용
- 개수 배지 표시 (예: "위치 (1)")
- 활성화된 필터를 다른 색으로 표시
```

**디자인 패턴:**
- ActionSheet 대신 Bottom Sheet 필터 피커 사용
- 위치에 대한 다중 선택 지원 (예: 서울 + 인천)
- 명확한 "모두 초기화" 버튼
- 적용/취소 버튼

#### 2. 컴팩트 캘린더
**30일 뷰로 축소:**
- 오늘 날짜 강조 표시
- 요일 약자 표시 (월, 화, 수...)
- 특정 월로 이동하는 월 선택기
- 제안 날짜: 오늘, 내일, 이번 주말

#### 3. 필터 태그 표시
**캘린더 아래 인라인 태그 표시:**
```
[위치: 강남구] [포지션: DF] [실력: 중급]    [X 초기화]
```

#### 4. 빈 상태 개선
- 결과가 없을 때 관련 메시지 표시
- 필터 조정 제안

### 데이터/API 요구사항
서버 팀이 제공해야 할 사항:
- `GET /mercenary/locations` - 사용 가능한 위치 목록
- `GET /mercenary/positions` - 사용 가능한 포지션
- 필터 엔드포인트는 다중 선택 지원해야 함

---

## 3. 이전 매칭 불러오기 & 재활용 - 이전 매칭 불러오기 및 재사용

### 현재 상태

**기존 컴포넌트:**
- `CallPreviusMatchingInformationView`가 존재하지만 스텁 형태
- 4개 항목에 대한 플레이스홀더만 표시
- API와의 실제 데이터 통합 없음

### 권장 구현 방식

#### 아키텍처

**데이터 모델:**
```swift
struct MatchTemplate {
    let id: Int
    let title: String
    let date: Date?
    let location: String
    let matchType: String // "6v6" 또는 "11v11"
    let genderType: String
    let shoesRequirement: String
    let fee: Int
    let teamName: String
    let ageRange: (min: Int, max: Int)
    let skillLevel: String
    let tags: [String] // 예: ["강남", "저녁 경기"]
    let createdDate: Date
    let lastUsedDate: Date?
}
```

#### UI/UX 플로우

**옵션 1: 불러오기 & 편집 플로우**
1. "이전 글 불러오기" 버튼 클릭
2. 다음을 포함한 모달 표시:
   - 위치 또는 날짜로 검색/필터
   - 저장된 템플릿 목록:
     - 날짜/위치/경기 종류가 있는 썸네일
     - "사용하기" 버튼
     - 삭제 옵션
3. "사용하기" 클릭 → 템플릿 데이터로 폼 미리 채우기
4. 사용자가 필요한 대로 편집

**옵션 2: 빠른 복사 플로우**
1. 경기 히스토리의 각 매치 옆에 작은 "+" 아이콘 표시
2. 이전 매치를 오래 누르기 → 복사 옵션 메뉴
3. 생성 화면에 템플릿 제안 표시

#### UI 디자인

**모달 레이아웃:**
```
┌──────────────────────────────────┐
│ 이전 경기 불러오기              │ [X]
├──────────────────────────────────┤
│ 🔍 [검색...........................] │
├──────────────────────────────────┤
│ 최근 (최근 사용순)               │
│                                  │
│ ┌────────────────────────────┐   │
│ │ 강남 구장 - 6v6           │   │
│ │ 2025년 1월 15일 19:00     │ ▸ │
│ │ 남성 매치 • 5,000원        │   │
│ └────────────────────────────┘   │
│ ┌────────────────────────────┐   │
│ │ 태릉 경기장 - 11v11        │   │
│ │ 2025년 1월 10일 20:00     │ ▸ │
│ │ 혼성 매치 • 10,000원       │   │
│ └────────────────────────────┘   │
│                                  │
│ 인기 있는 것 (가장 많이 사용)     │
│ [더 많은 항목...]                │
├──────────────────────────────────┤
│    [취소]        [사용하기]      │
└──────────────────────────────────┘
```

#### API 요구사항
- `GET /matches/templates` - 사용자의 저장된 매치 템플릿 가져오기
- `GET /matches/templates/{id}` - 템플릿 상세 정보 가져오기
- `POST /matches/templates` - 현재 폼을 템플릿으로 저장
- `PUT /matches/templates/{id}/lastUsed` - 마지막 사용 시간 업데이트
- `DELETE /matches/templates/{id}` - 템플릿 삭제

---

## 4. 필터링 개선 - 향상된 필터링 메커니즘

### 현재 상태 분석

**팀 모집 필터링:**
- 생성 플로우에는 필터링 없음 (매칭/탐색에만 있음)

**GameMatchingViewController 분석:**
- 일부 필터링이 있을 가능성 (작업에 언급되었지만 확인 필요)
- MercenaryMatch는 이미 기본 포지션/위치/실력 필터링 있음

### 권장 다단계 필터링 전략

#### 1단계: 빠른 필터 (가장 일반적)
- 성별 (남, 여, 혼성)
- 실력 (초급, 중급, 상급)
- 시간대 (아침, 오후, 저녁)
- 가격대 슬라이더

#### 2단계: 고급 필터 (덜 일반적)
- 날짜 범위 선택기
- 위치 with 반경/지도
- 신발 종류
- 나이 범위
- 필요한 특정 포지션

#### 3단계: 저장된 필터
- 사용자가 필터 프리셋 저장 가능
- "내 선호도" 빠른 접근
- "최근 검색" 스마트 제안

#### 구현 패턴

**필터 상태 관리:**
```swift
struct FilterState {
    var genderType: [String] = []
    var skillLevel: [String] = []
    var timeOfDay: [String] = []
    var priceRange: ClosedRange<Int> = 0...50000
    var isActive: Bool { /* 설정된 필터 확인 */ }

    mutating func reset() { /* 모두 초기화 */ }
}
```

**UI 컴포넌트:**
- 선택을 위한 태그 기반 필터
- 가격/나이 범위 슬라이더
- 성별 토글 버튼
- 상단 저장된 필터 칩

#### 시각적 디자인

```
┌─────────────────────────────────┐
│ 필터 (3 적용됨)         [X 초기화] │
├─────────────────────────────────┤
│ 🔖 태그 기반 빠른 선택:          │
│ [남성 매치] [여성 매치] [혼성 ✓]  │
│                               │
│ 실력: [초급] [중급] [상급 ✓]   │
│ 시간: [아침] [오후] [저녁 ✓]   │
│                               │
│ ≡ 고급 옵션 ▼                  │
│ (가격, 날짜범위, 위치 등)    │
├─────────────────────────────────┤
│    [적용]        [초기화]      │
└─────────────────────────────────┘
```

---

## 기술적 구현 우선순위

### 높음 우선순위 (기초)
1. **일관된 데이터 모델 정의** - 팀 & 용병 모집 전체
2. **템플릿 저장/로드 API 구현** - 재사용 가능한 매칭
3. **공유 FilterView 컴포넌트 생성** - 앱 전체에서 사용

### 중간 우선순위 (개선)
4. 폼 유효성 검사 로직을 공유 유틸리티로 리팩토링
5. MatchTemplate 캐싱 구현
6. 필터 사용 패턴에 대한 분석 추가

### 낮은 우선순위 (마무리)
7. 필터 라벨 현지화
8. 다양한 필터 UI 패턴 A/B 테스트
9. 사용자 히스토리 기반 스마트 제안

---

## 필요한 API 엔드포인트

### 이전 매칭 기능용
```
GET    /api/matches/templates
GET    /api/matches/templates/{id}
POST   /api/matches/templates
PUT    /api/matches/templates/{id}
DELETE /api/matches/templates/{id}
PUT    /api/matches/templates/{id}/lastUsed
```

### 용병 필터링용
```
GET    /api/mercenary/locations
GET    /api/mercenary/positions
GET    /api/mercenary/requests?filters=location,position,skill
```

### 팀 매칭용
```
GET    /api/teams?filters=...
POST   /api/matches/templates (템플릿 저장 시)
```

---

## 권장 구현 순서

1. **1단계** (1-2주):
   - 팀 모집 단순화 (2개 화면 통합 또는 플로우 재설계)
   - 용병 필터 UI 개선

2. **2단계** (2-3주):
   - 이전 매칭 기능 구현
   - 템플릿 저장/로드 기능 추가

3. **3단계** (3-4주):
   - 모든 기능에 걸친 고급 필터링
   - 저장된 필터 프리셋
   - 분석 통합

---

## 디자인 시스템 노트

**현재 색상 체계:**
- 주요색: 빨강 `#EC5F5F` (rgb: 236, 95, 95)
- 보조색: 파랑 `#3399FF` (rgb: 51, 153, 255)
- 배경: 밝은 회색 `#F6F7FA` (rgb: 246, 247, 250)
- 텍스트: 검정/진한 회색 `#363738` (rgb: 54, 55, 56)

**타이포그래피:**
- 제목: System Font, Semibold, 16-18pt
- 본문: System Font, Regular, 14pt
- 캡션: System Font, Regular, 12pt

**생성할 컴포넌트:**
- 재사용 가능한 FilterSheet (Bottom sheet 모달)
- TemplateCard (이전 매칭용)
- MatchTemplate 선택 뷰
- 축소 가능한 섹션 뷰

---

## 다음 단계

1. **디자인 팀과 접근 방식 검증**
2. **비즈니스 지표에 따라 구현 우선순위 지정**
3. **승인된 변경사항에 대한 상세 와이어프레임 생성**
4. **서버 팀과 API 요구사항 조정**
5. **주요 변경사항에 대한 A/B 테스트 계획 수립**
